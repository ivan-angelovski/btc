<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Flow - Lines Only</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #chart-container {
      width: 100%;
      height: 100%;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .link {
      fill: none;
      stroke: #fff;
    }
    
    .node-label {
      fill: #fff;
      font-size: 12px;
    }
    
    .tooltip {
      position: absolute;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.9);
      color: white;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      pointer-events: none;
      font-size: 14px;
      z-index: 10;
      max-width: 400px;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 24px;
      color: white;
    }
    
    #error {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 15px;
      background-color: rgba(220, 53, 69, 0.9);
      color: white;
      border-radius: 4px;
      z-index: 1000;
      max-width: 80%;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Bitcoin Flow Data...</div>
  <div id="error" style="display: none;"></div>
  <div id="chart-container"></div>

  <!-- Load D3.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <!-- Load PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      createBitcoinFlowVisualization();
    });
    
    // Initial scale is zoomed out to show the full network
    const initialScale = 0.4;
    
    async function createBitcoinFlowVisualization() {
      const csvFile = 'combined.csv';
      
      // Create tooltip div
      const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);
      
      try {
        // Fetch CSV data
        const response = await fetch(csvFile);
        if (!response.ok) {
          throw new Error(`Failed to load CSV file: ${response.statusText}`);
        }
        
        const csvData = await response.text();
        processCSVData(csvData);
      } catch (error) {
        showError(`Error: ${error.message}`);
        hideLoading();
      }
      
      function processCSVData(csvText) {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true,
          complete: function(results) {
            if (results.errors.length > 0) {
              showError(`Error parsing CSV: ${results.errors[0].message}`);
              hideLoading();
              return;
            }
            
            try {
              const data = results.data;
              if (data.length === 0) {
                showError('No data found in the CSV file');
                hideLoading();
                return;
              }
              
              // Process data
              const flowData = processDataForFlow(data);
              
              // Create the flow visualization
              createFlowVisualization(flowData, tooltip);
              
              // Hide loading indicator
              hideLoading();
            } catch (error) {
              showError(`Error processing data: ${error.message}`);
              hideLoading();
            }
          },
          error: function(error) {
            showError(`Failed to parse CSV: ${error.message}`);
            hideLoading();
          }
        });
      }
    }
    
    function processDataForFlow(rawData) {
      const firstRow = rawData[0];
      
      // Use the exact column names
      let sourceColumn = "From (Full)";
      let targetColumn = "To (Full)";
      let valueColumn = "Amount (BTC)";
      
      // Fallback column detection if needed
      if (!firstRow.hasOwnProperty(sourceColumn)) {
        const columns = Object.keys(firstRow);
        sourceColumn = columns.find(col => 
          col.toLowerCase().includes('from') || 
          col.toLowerCase().includes('source')
        ) || columns[0];
      }
      
      if (!firstRow.hasOwnProperty(targetColumn)) {
        const columns = Object.keys(firstRow);
        targetColumn = columns.find(col => 
          col.toLowerCase().includes('to') || 
          col.toLowerCase().includes('target')
        ) || columns[1];
      }
      
      if (!firstRow.hasOwnProperty(valueColumn)) {
        const columns = Object.keys(firstRow);
        valueColumn = columns.find(col => 
          col.toLowerCase().includes('amount') || 
          col.toLowerCase().includes('value') || 
          col.toLowerCase().includes('btc')
        );
      }
      
      // Set up node tracking
      const sourceNodes = new Set();
      const targetNodes = new Set();
      const allLinks = [];
      
      // Process each row
      rawData.forEach(row => {
        const source = String(row[sourceColumn]);
        const target = String(row[targetColumn]);
        
        // Skip invalid rows
        if (!source || !target || source === target) return;
        
        // Get short names if available
        const sourceShort = row["From (Short)"] || source.substring(0, 6);
        const targetShort = row["To (Short)"] || target.substring(0, 6);
        
        // Add to our sets
        sourceNodes.add(source);
        targetNodes.add(target);
        
        // Get value (default to 1 if not specified)
        const value = valueColumn && row[valueColumn] ? Number(row[valueColumn]) : 1;
        
        // Add to links
        allLinks.push({
          source,
          target,
          sourceShort,
          targetShort,
          value
        });
      });
      
      return {
        sources: Array.from(sourceNodes),
        targets: Array.from(targetNodes),
        links: allLinks
      };
    }
    
    function createFlowVisualization(data, tooltip) {
      const container = document.getElementById('chart-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      // Create a larger virtual canvas for spreading out
      const virtualWidth = Math.max(width * 4, 6000);
      const virtualHeight = Math.max(height * 4, 4000);
      
      // Remove any existing SVG
      d3.select('#chart-container').selectAll('*').remove();
      
      // Create new SVG with the virtual size as viewBox
      const svg = d3.select('#chart-container')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, virtualWidth, virtualHeight]);
      
      // Create a group for the flow diagram
      const g = svg.append('g');
      
      // Define zoom function
      function zoomed(event) {
        g.attr('transform', event.transform);
      }
      
      // Set up zoom behavior
      const zoom = d3.zoom()
        .scaleExtent([0.05, 15])  // Allow extensive zooming
        .on('zoom', zoomed);
      
      // Apply zoom, initially centered and zoomed out
      svg.call(zoom)
         .call(zoom.transform, d3.zoomIdentity
           .scale(initialScale)
           .translate(virtualWidth/4, virtualHeight/4));
           
      // Setup positions for source and target nodes
      const sourceX = 200;
      const targetX = virtualWidth - 200;
      
      // Calculate vertical spacing to completely avoid overlap
      // We'll position each node with equal vertical spacing
      const sourcesCount = data.sources.length;
      const sourceSpacing = virtualHeight / (sourcesCount + 1);
      
      const targetsCount = data.targets.length;
      const targetSpacing = virtualHeight / (targetsCount + 1);
      
      // Map sources and targets to their Y positions
      const sourcePositions = new Map();
      data.sources.forEach((source, i) => {
        sourcePositions.set(source, (i + 1) * sourceSpacing);
      });
      
      const targetPositions = new Map();
      data.targets.forEach((target, i) => {
        targetPositions.set(target, (i + 1) * targetSpacing);
      });
      
      // Function to create curved path between points
      function createCurvedPath(source, target, sourceY, targetY) {
        // Control points for the curve
        const controlX1 = sourceX + (targetX - sourceX) * 0.33;
        const controlX2 = sourceX + (targetX - sourceX) * 0.66;
        
        return `M${sourceX},${sourceY} 
                C${controlX1},${sourceY} 
                 ${controlX2},${targetY} 
                 ${targetX},${targetY}`;
      }
      
      // Draw the flow lines
      const links = g.selectAll('.link')
        .data(data.links)
        .enter()
        .append('path')
        .attr('class', 'link')
        .attr('d', d => {
          const sourceY = sourcePositions.get(d.source);
          const targetY = targetPositions.get(d.target);
          return createCurvedPath(sourceX, targetX, sourceY, targetY);
        })
        .attr('stroke', '#ffffff')
        .attr('stroke-width', d => Math.sqrt(d.value) * 2) // Scale line width by square root of value
        .attr('stroke-opacity', 0.15)
        .attr('fill', 'none')
        .on('mouseover', function(event, d) {
          d3.select(this)
            .attr('stroke-opacity', 0.6)
            .attr('stroke-width', d => Math.sqrt(d.value) * 2.5);
          
          // Show tooltip
          tooltip.transition()
            .duration(200)
            .style('opacity', 0.9);
          
          tooltip.html(`<strong>From:</strong> ${d.source}<br>` +
                      `<strong>To:</strong> ${d.target}<br>` +
                      `<strong>Amount:</strong> ${d.value.toFixed(8)} BTC`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
          d3.select(this)
            .attr('stroke-opacity', 0.15)
            .attr('stroke-width', d => Math.sqrt(d.value) * 2);
          
          // Hide tooltip
          tooltip.transition()
            .duration(500)
            .style('opacity', 0);
        });
      
      // Add source labels (small, only showing the short version)
      g.selectAll('.source-label')
        .data(data.sources)
        .enter()
        .append('text')
        .attr('class', 'node-label')
        .attr('x', sourceX - 10)
        .attr('y', d => sourcePositions.get(d))
        .attr('text-anchor', 'end')
        .attr('alignment-baseline', 'middle')
        .attr('font-size', '12px')
        .attr('fill', 'rgba(255, 255, 255, 0.7)')
        .text(d => {
          // Find the short name from links
          const link = data.links.find(l => l.source === d);
          return link ? link.sourceShort : d.substring(0, 6);
        });
      
      // Add target labels (small, only showing the short version)
      g.selectAll('.target-label')
        .data(data.targets)
        .enter()
        .append('text')
        .attr('class', 'node-label')
        .attr('x', targetX + 10)
        .attr('y', d => targetPositions.get(d))
        .attr('text-anchor', 'start')
        .attr('alignment-baseline', 'middle')
        .attr('font-size', '12px')
        .attr('fill', 'rgba(255, 255, 255, 0.7)')
        .text(d => {
          // Find the short name from links
          const link = data.links.find(l => l.target === d);
          return link ? link.targetShort : d.substring(0, 6);
        });
      
      // Add subtle hint text
      svg.append('text')
        .attr('x', 20)
        .attr('y', virtualHeight - 20)
        .attr('text-anchor', 'start')
        .attr('font-size', '14px')
        .attr('fill', 'rgba(255, 255, 255, 0.3)')
        .text('Scroll to zoom, drag to pan');
    }
    
    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }
    
    function showError(message) {
      const errorElement = document.getElementById('error');
      errorElement.textContent = message;
      errorElement.style.display = 'block';
      
      // Hide error after 10 seconds
      setTimeout(() => {
        errorElement.style.display = 'none';
      }, 10000);
    }
  </script>
</body>
</html>
