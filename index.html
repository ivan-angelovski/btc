<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Wallet Flow</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #chart-container {
      width: 100%;
      height: 100%;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .link {
      fill: none;
      stroke: #fff;
    }
    
    .node rect {
      fill: #1a1a1a;
      stroke: #fff;
      stroke-width: 2px;
    }
    
    .node text {
      fill: #fff;
      font-size: 12px;
    }
    
    .tooltip {
      position: absolute;
      padding: 15px;
      background-color: rgba(40, 40, 40, 0.95);
      color: white;
      border-radius: 4px;
      border: 2px solid rgba(255, 255, 255, 0.5);
      pointer-events: none;
      font-size: 14px;
      font-weight: bold;
      z-index: 10;
      max-width: 400px;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 24px;
      color: white;
    }
    
    #error {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 15px;
      background-color: rgba(220, 53, 69, 0.9);
      color: white;
      border-radius: 4px;
      z-index: 1000;
      max-width: 80%;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Bitcoin Wallet Flow Data...</div>
  <div id="error" style="display: none;"></div>
  <div id="chart-container"></div>

  <!-- Load D3.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <!-- Load D3-Sankey -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-sankey/0.12.3/d3-sankey.min.js"></script>
  <!-- Load PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <script>
    // Apply a better initial zoom level to make the graph more visible
    let initialScale = 0.85;  // Slightly zoomed out to show more context
    
    // Main function to create the Sankey diagram
    async function createBitcoinFlowVisualization() {
      const csvFile = 'combined.csv';
      let tooltip;
      
      // Create tooltip
      tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);
      
      try {
        // Fetch CSV data
        const response = await fetch(csvFile);
        if (!response.ok) {
          throw new Error(`Failed to load CSV file: ${response.statusText}`);
        }
        
        const csvData = await response.text();
        processCSVData(csvData);
      } catch (error) {
        showError(`Error: ${error.message}`);
        hideLoading();
      }
      
      function processCSVData(csvText) {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true,
          complete: function(results) {
            if (results.errors.length > 0) {
              showError(`Error parsing CSV: ${results.errors[0].message}`);
              hideLoading();
              return;
            }
            
            try {
              const data = results.data;
              if (data.length === 0) {
                showError('No data found in the CSV file');
                hideLoading();
                return;
              }
              
              // Process data for Sankey diagram
              const sankeyData = processDataForSankey(data);
              createSankeyDiagram(sankeyData);
              hideLoading();
            } catch (error) {
              showError(`Error processing data: ${error.message}`);
              hideLoading();
            }
          },
          error: function(error) {
            showError(`Failed to parse CSV: ${error.message}`);
            hideLoading();
          }
        });
      }
      
      function processDataForSankey(rawData) {
        // Identify columns
        const firstRow = rawData[0];
        
        // Use the exact column names
        let sourceColumn = "From (Full)";
        let targetColumn = "To (Full)";
        let valueColumn = "Amount (BTC)";
        
        // Fallback column detection if needed
        if (!firstRow.hasOwnProperty(sourceColumn)) {
          const columns = Object.keys(firstRow);
          sourceColumn = columns.find(col => 
            col.toLowerCase().includes('from') || 
            col.toLowerCase().includes('source')
          ) || columns[0];
        }
        
        if (!firstRow.hasOwnProperty(targetColumn)) {
          const columns = Object.keys(firstRow);
          targetColumn = columns.find(col => 
            col.toLowerCase().includes('to') || 
            col.toLowerCase().includes('target')
          ) || columns[1];
        }
        
        if (!firstRow.hasOwnProperty(valueColumn)) {
          const columns = Object.keys(firstRow);
          valueColumn = columns.find(col => 
            col.toLowerCase().includes('amount') || 
            col.toLowerCase().includes('value') || 
            col.toLowerCase().includes('btc')
          );
        }
        
        // Create nodes and links
        const nodeMap = new Map();
        const links = [];
        
        // Process each row
        rawData.forEach(row => {
          const source = String(row[sourceColumn]);
          const target = String(row[targetColumn]);
          
          // Skip invalid rows
          if (!source || !target || source === target) return;
          
          // Get short names if available
          const sourceShort = row["From (Short)"] || source.substring(0, 6);
          const targetShort = row["To (Short)"] || target.substring(0, 6);
          
          // Add nodes if they don't exist
          if (!nodeMap.has(source)) {
            nodeMap.set(source, { 
              id: source, 
              name: source,
              shortName: sourceShort
            });
          }
          
          if (!nodeMap.has(target)) {
            nodeMap.set(target, { 
              id: target, 
              name: target,
              shortName: targetShort
            });
          }
          
          // Get value (default to 1 if not specified)
          const value = valueColumn && row[valueColumn] ? Number(row[valueColumn]) : 1;
          
          // Add link or update existing link
          const existingLink = links.find(link => 
            link.source === source && link.target === target);
          
          if (existingLink) {
            existingLink.value += value;
          } else {
            links.push({
              source: source,
              target: target,
              value: value
            });
          }
        });
        
        // Convert maps to arrays
        const nodes = Array.from(nodeMap.values());
        
        return { nodes, links };
      }
      
      function createSankeyDiagram(data) {
        const container = document.getElementById('chart-container');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Remove any existing SVG
        d3.select('#chart-container').selectAll('*').remove();
        
        // Create new SVG
        const svg = d3.select('#chart-container')
          .append('svg')
          .attr('width', width)
          .attr('height', height)
          .attr('viewBox', [0, 0, width, height]);
        
        // Define the zoom function first
        function zoomed(event) {
          g.attr('transform', event.transform);
        }
        
        // Set up zoom behavior
        const zoom = d3.zoom()
          .scaleExtent([0.1, 10])
          .on('zoom', zoomed);
        
        svg.call(zoom)
           .call(zoom.transform, d3.zoomIdentity.scale(initialScale).translate(width * 0.05, height * 0.05));
        
        // Create a group for the Sankey diagram
        const g = svg.append('g');
        
        // Initialize the Sankey generator with much larger node padding
        const sankey = d3.sankey()
          .nodeId(d => d.id)
          .nodeWidth(25)
          .nodePadding(80)  // Significantly increased padding between nodes
          .extent([[100, 100], [width - 100, height - 100]]);
        
        // Generate the Sankey layout
        const sankeyData = sankey(data);
        
        // Create color scale for the nodes
        const nodeColorScale = d3.scaleOrdinal()
          .domain(sankeyData.nodes.map(d => d.id))
          .range(['#333333', '#444444', '#555555']);
        
        // Draw the links
        const link = g.append('g')
          .attr('class', 'links')
          .attr('fill', 'none')
          .selectAll('path')
          .data(sankeyData.links)
          .enter().append('path')
          .attr('d', d3.sankeyLinkHorizontal())
          .attr('stroke', '#ffffff')
          .attr('stroke-width', d => Math.max(1, d.width))
          .attr('stroke-opacity', 0.15)
          .attr('class', 'link')
          .on('mouseover', function(event, d) {
            d3.select(this)
              .attr('stroke-opacity', 0.4)
              .attr('stroke-width', d => Math.max(2, d.width + 2));
            
            // Show tooltip
            tooltip.transition()
              .duration(200)
              .style('opacity', 0.9);
            
            tooltip.html(`<strong>From:</strong> ${d.source.name}<br>` +
                        `<strong>To:</strong> ${d.target.name}<br>` +
                        `<strong>Amount:</strong> ${d.value.toFixed(8)} BTC`)
              .style('left', (event.pageX + 10) + 'px')
              .style('top', (event.pageY - 28) + 'px');
          })
          .on('mouseout', function() {
            d3.select(this)
              .attr('stroke-opacity', 0.15)
              .attr('stroke-width', d => Math.max(1, d.width));
            
            // Hide tooltip
            tooltip.transition()
              .duration(500)
              .style('opacity', 0);
          });
        
        // Draw the nodes
        const node = g.append('g')
          .attr('class', 'nodes')
          .selectAll('g')
          .data(sankeyData.nodes)
          .enter().append('g');
        
        // Add rectangles for the nodes with increased minimum height
        node.append('rect')
          .attr('x', d => d.x0)
          .attr('y', d => d.y0)
          .attr('height', d => Math.max(20, d.y1 - d.y0))  // Minimum height of 20px for better visibility
          .attr('width', d => d.x1 - d.x0)
          .attr('fill', d => nodeColorScale(d.id))
          .attr('stroke', '#ffffff')
          .attr('stroke-width', 1)
          .attr('class', 'node')
          .on('mouseover', function(event, d) {
            d3.select(this)
              .attr('stroke-width', 2)
              .attr('stroke', '#ffffff');
            
            // Show tooltip
            tooltip.transition()
              .duration(200)
              .style('opacity', 0.9);
            
            tooltip.html(`<strong>Wallet:</strong> ${d.name}<br>` +
                        `<strong>Total Amount:</strong> ${d.value.toFixed(8)} BTC`)
              .style('left', (event.pageX + 10) + 'px')
              .style('top', (event.pageY - 28) + 'px');
          })
          .on('mouseout', function() {
            d3.select(this)
              .attr('stroke-width', 1);
            
            // Hide tooltip
            tooltip.transition()
              .duration(500)
              .style('opacity', 0);
          });
        
        // Add labels for the nodes on the opposite side of the lines for better readability
        node.append('text')
          .attr('x', d => d.x0 < width / 2 ? d.x0 - 10 : d.x1 + 10)  // Opposite side of the node from the lines
          .attr('y', d => (d.y1 + d.y0) / 2)
          .attr('dy', '0.35em')
          .attr('text-anchor', d => d.x0 < width / 2 ? 'end' : 'start')  // Text alignment reversed
          .text(d => d.shortName || d.name.substring(0, 10))
          .attr('class', 'node-text')
          .style('pointer-events', 'none')
          .style('fill', '#ffffff')
          .style('font-size', '14px')  // Larger font size for better readability
          .style('font-weight', 'bold');
        
        // Add a watermark with hover info
        svg.append('text')
          .attr('x', 10)
          .attr('y', height - 10)
          .attr('text-anchor', 'start')
          .attr('font-size', '12px')
          .attr('fill', 'rgba(255, 255, 255, 0.3)')
          .text('Scroll to zoom, drag to pan');
      }
      
      function hideLoading() {
        document.getElementById('loading').style.display = 'none';
      }
      
      function showError(message) {
        const errorElement = document.getElementById('error');
        errorElement.textContent = message;
        errorElement.style.display = 'block';
        
        // Hide error after 10 seconds
        setTimeout(() => {
          errorElement.style.display = 'none';
        }, 10000);
      }
    }
    
    // Initialize visualization when the page loads
    document.addEventListener('DOMContentLoaded', createBitcoinFlowVisualization);
  </script>
</body>
</html>
