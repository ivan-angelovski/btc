<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Flow - FULL Dataset</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #chart-container {
      width: 100%;
      height: 100%;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .link {
      stroke: #fff;
      stroke-opacity: 0.15;
    }
    
    .node {
      font-size: 12px;
      fill: #fff;
      text-anchor: middle;
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 24px;
      color: white;
    }
    
    #progress {
      width: 80%;
      height: 20px;
      background-color: #333;
      margin-top: 20px;
      border-radius: 10px;
      overflow: hidden;
    }
    
    #progress-bar {
      height: 100%;
      background-color: #4CAF50;
      width: 0%;
      transition: width 0.2s;
    }
    
    #error {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 15px;
      background-color: rgba(220, 53, 69, 0.9);
      color: white;
      border-radius: 4px;
      z-index: 1000;
      max-width: 80%;
    }
    
    #controls {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.8);
      border-radius: 4px;
      z-index: 100;
      max-width: 300px;
    }
    
    button {
      background: #333;
      color: white;
      border: 1px solid #555;
      padding: 8px 12px;
      margin: 5px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 14px;
    }
    
    button:hover {
      background: #444;
    }
    
    button:active {
      background: #555;
    }
    
    #limit-slider {
      width: 100%;
      margin: 10px 0;
    }
    
    label {
      display: block;
      margin: 8px 0;
      font-size: 14px;
    }
    
    input[type=number] {
      width: 100px;
      padding: 5px;
      background: #333;
      color: white;
      border: 1px solid #555;
      border-radius: 3px;
    }
    
    .button-row {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    
    .zoom-controls {
      display: flex;
      justify-content: center;
      margin-top: 10px;
    }
    
    #status-message {
      position: fixed;
      bottom: 20px;
      left: 20px;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 4px;
      z-index: 100;
      font-size: 14px;
      max-width: 80%;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div>Loading Bitcoin Flow Data...</div>
    <div id="status">Parsing CSV file</div>
    <div id="progress">
      <div id="progress-bar"></div>
    </div>
  </div>
  
  <div id="error" style="display: none;"></div>
  
  <div id="controls" style="display: none;">
    <label for="transaction-limit">Transaction Limit:</label>
    <input type="number" id="transaction-limit" min="100" max="100000" step="100" value="1000">
    
    <label for="spacing-slider">Node Spacing:</label>
    <input type="range" id="spacing-slider" min="50" max="500" step="10" value="200">
    <span id="spacing-value">200</span>
    
    <div class="button-row">
      <button id="redraw">Redraw</button>
      <button id="show-all">Show ALL Data</button>
    </div>
    
    <div class="zoom-controls">
      <button id="zoom-out">âˆ’</button>
      <button id="center">Reset View</button>
      <button id="zoom-in">+</button>
    </div>
  </div>
  
  <div id="status-message" style="display: none;"></div>
  
  <div id="chart-container"></div>

  <!-- Load D3.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <!-- Load PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <script>
    // Global variables
    let allLinks = [];
    let svg, g, zoom;
    let currentLimit = 1000;
    let nodeSpacing = 200;
    let isShowingAll = false;
    
    document.addEventListener('DOMContentLoaded', function() {
      // Set up controls
      document.getElementById('transaction-limit').addEventListener('input', function() {
        currentLimit = parseInt(this.value);
        if (isNaN(currentLimit) || currentLimit < 100) {
          currentLimit = 100;
        }
      });
      
      document.getElementById('spacing-slider').addEventListener('input', function() {
        nodeSpacing = parseInt(this.value);
        document.getElementById('spacing-value').textContent = nodeSpacing;
      });
      
      document.getElementById('redraw').addEventListener('click', function() {
        isShowingAll = false;
        updateVisualization(allLinks, currentLimit);
      });
      
      document.getElementById('show-all').addEventListener('click', function() {
        isShowingAll = true;
        // Warning for very large datasets
        if (allLinks.length > 10000) {
          if (confirm(`WARNING: Rendering all ${allLinks.length} transactions may cause your browser to become unresponsive. Continue?`)) {
            updateVisualization(allLinks, allLinks.length);
          }
        } else {
          updateVisualization(allLinks, allLinks.length);
        }
      });
      
      document.getElementById('center').addEventListener('click', function() {
        centerView();
      });
      
      document.getElementById('zoom-in').addEventListener('click', function() {
        svg.transition().duration(300).call(zoom.scaleBy, 1.5);
      });
      
      document.getElementById('zoom-out').addEventListener('click', function() {
        svg.transition().duration(300).call(zoom.scaleBy, 0.67);
      });
      
      // Start loading data
      loadCSVAndCreateTree();
    });
    
    async function loadCSVAndCreateTree() {
      const csvFile = 'combined.csv';
      
      try {
        updateStatus("Attempting to load CSV file...");
        console.log("Attempting to load CSV file:", csvFile);
        
        // Fetch CSV data
        const response = await fetch(csvFile);
        if (!response.ok) {
          throw new Error(`Failed to load CSV file: ${response.statusText}`);
        }
        
        const csvData = await response.text();
        console.log("CSV loaded successfully, length:", csvData.length);
        updateStatus("Parsing CSV data...");
        updateProgress(20);
        
        // Parse CSV with streaming for large files
        Papa.parse(csvData, {
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true,
          complete: function(results) {
            if (results.errors.length > 0) {
              showError(`Error parsing CSV: ${results.errors[0].message}`);
              return;
            }
            
            try {
              const data = results.data;
              if (data.length === 0) {
                showError('No data found in the CSV file');
                return;
              }
              
              console.log("CSV parsed successfully, records:", data.length);
              updateStatus(`Processing ${data.length} records...`);
              updateProgress(40);
              
              // Process CSV data into links
              setTimeout(() => {
                allLinks = processCSVToTreeLinks(data);
                updateProgress(60);
                
                // Set up SVG and initial visualization
                setTimeout(() => {
                  setupSVG();
                  updateStatus("Creating visualization...");
                  updateProgress(80);
                  
                  // Create visualization with limited data for performance
                  setTimeout(() => {
                    updateVisualization(allLinks, currentLimit);
                    updateProgress(100);
                    
                    // Show controls
                    document.getElementById('controls').style.display = 'block';
                    
                    // Hide loading indicator after a short delay
                    setTimeout(() => {
                      document.getElementById('loading').style.display = 'none';
                    }, 500);
                  }, 100);
                }, 100);
              }, 100);
            } catch (error) {
              showError(`Error processing data: ${error.message}`);
              console.error("Data processing error:", error);
            }
          },
          error: function(error) {
            showError(`Failed to parse CSV: ${error.message}`);
            console.error("CSV parsing error:", error);
          }
        });
      } catch (error) {
        showError(`Error: ${error.message}`);
        console.error("CSV loading error:", error);
      }
    }
    
    function processCSVToTreeLinks(csvData) {
      updateStatus("Extracting wallet connections...");
      
      const firstRow = csvData[0];
      
      // Use the exact column names from your CSV
      let sourceColumn = "From (Full)";
      let targetColumn = "To (Full)";
      
      // Fallback column detection if needed
      if (!firstRow.hasOwnProperty(sourceColumn)) {
        const columns = Object.keys(firstRow);
        sourceColumn = columns.find(col => 
          col.toLowerCase().includes('from') || 
          col.toLowerCase().includes('source')
        ) || columns[0];
      }
      
      if (!firstRow.hasOwnProperty(targetColumn)) {
        const columns = Object.keys(firstRow);
        targetColumn = columns.find(col => 
          col.toLowerCase().includes('to') || 
          col.toLowerCase().includes('target')
        ) || columns[1];
      }
      
      console.log("Using columns:", sourceColumn, "->", targetColumn);
      
      // Extract links
      const links = [];
      csvData.forEach((row, i) => {
        if (i % 1000 === 0) {
          updateStatus(`Processing record ${i} of ${csvData.length}...`);
        }
        
        const source = row[sourceColumn];
        const target = row[targetColumn];
        
        // Use short versions if available
        const sourceShort = row["From (Short)"] || 
                           (typeof source === 'string' ? source.substring(0, 6) : source);
        const targetShort = row["To (Short)"] || 
                           (typeof target === 'string' ? target.substring(0, 6) : target);
        
        if (source && target && source !== target) {
          links.push({
            source: sourceShort,
            target: targetShort,
            originalSource: source,
            originalTarget: target,
            amount: row["Amount (BTC)"] || 1
          });
        }
      });
      
      console.log("Processed links:", links.length);
      return links;
    }
    
    function setupSVG() {
      const container = document.getElementById('chart-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      // Create main SVG
      svg = d3.select('#chart-container')
        .append('svg')
        .attr('width', width)
        .attr('height', height);
      
      // Create a group for the tree
      g = svg.append('g');
      
      // Set up zoom behavior
      zoom = d3.zoom()
        .scaleExtent([0.01, 20])  // Allow extremely deep zooming out
        .on('zoom', function(event) {
          g.attr('transform', event.transform);
        });
      
      svg.call(zoom);
    }
    
    function updateVisualization(links, limit) {
      // Clear previous visualization
      g.selectAll('*').remove();
      
      const message = isShowingAll ? 
        `Drawing ALL ${links.length} transactions...` : 
        `Drawing ${Math.min(limit, links.length)} of ${links.length} transactions...`;
      
      updateStatus(message);
      showStatusMessage(message + " This may take a moment.");
      
      console.log(message);
      
      // Use full data or limited subset
      const displayedLinks = isShowingAll ? links : links.slice(0, limit);
      
      // Extract all unique wallets
      const uniqueWallets = new Set();
      displayedLinks.forEach(link => {
        uniqueWallets.add(link.source);
        uniqueWallets.add(link.target);
      });
      
      // Create graph structure for efficient traversal
      const walletsMap = new Map();
      
      // Initialize all wallets
      uniqueWallets.forEach(wallet => {
        walletsMap.set(wallet, {
          id: wallet,
          outgoing: new Set(),
          incoming: new Set(),
          level: undefined
        });
      });
      
      // Populate connections
      displayedLinks.forEach(link => {
        const sourceWallet = walletsMap.get(link.source);
        const targetWallet = walletsMap.get(link.target);
        
        sourceWallet.outgoing.add(link.target);
        targetWallet.incoming.add(link.source);
      });
      
      // Find starting wallets (those with no incoming transactions)
      const startWallets = Array.from(walletsMap.values()).filter(w => w.incoming.size === 0);
      
      // Assign levels using BFS (non-recursive)
      const walletArray = Array.from(walletsMap.values());
      
      // First pass: Assign level 0 to starting wallets
      startWallets.forEach(wallet => {
        wallet.level = 0;
      });
      
      // Second pass: Use BFS to assign levels to all other wallets
      let changed = true;
      let iterations = 0;
      const MAX_ITERATIONS = 100; // Safety limit
      
      while (changed && iterations < MAX_ITERATIONS) {
        changed = false;
        iterations++;
        
        walletArray.forEach(wallet => {
          // For each wallet with incoming connections
          wallet.incoming.forEach(sourceId => {
            const sourceWallet = walletsMap.get(sourceId);
            
            // If source has a level and this wallet doesn't, or could be at a higher level
            if (sourceWallet.level !== undefined) {
              const newLevel = sourceWallet.level + 1;
              
              if (wallet.level === undefined || newLevel > wallet.level) {
                wallet.level = newLevel;
                changed = true;
              }
            }
          });
        });
      }
      
      // Fallback for any wallets without a level
      walletArray.forEach(wallet => {
        if (wallet.level === undefined) {
          if (wallet.incoming.size === 0) {
            wallet.level = 0; // Source-only
          } else if (wallet.outgoing.size === 0) {
            wallet.level = iterations; // Target-only
          } else {
            wallet.level = 1; // Middle node
          }
        }
      });
      
      // Calculate container dimensions
      const container = document.getElementById('chart-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      // Find max level
      const maxLevel = Math.max(...walletArray.map(w => w.level));
      
      // Group wallets by level
      const walletsByLevel = {};
      walletArray.forEach(wallet => {
        if (!walletsByLevel[wallet.level]) {
          walletsByLevel[wallet.level] = [];
        }
        walletsByLevel[wallet.level].push(wallet);
      });
      
      // EXTREMELY LARGE virtual canvas for maximum spreading
      const virtualWidth = Math.max(width * 10, (maxLevel + 1) * 2000);
      const maxWalletsInAnyLevel = Math.max(...Object.values(walletsByLevel).map(w => w.length));
      const virtualHeight = Math.max(height * 10, maxWalletsInAnyLevel * nodeSpacing * 2);
      
      // Assign positions to wallets with EXTREME spacing
      const walletPositions = {};
      const columnWidth = virtualWidth / (maxLevel + 2);
      
      Object.entries(walletsByLevel).forEach(([level, walletsInLevel]) => {
        const levelX = 500 + parseInt(level) * columnWidth; // Extreme horizontal spacing
        const levelHeight = virtualHeight - 1000;
        const rowSpacing = levelHeight / (walletsInLevel.length + 1);
        
        walletsInLevel.forEach((wallet, i) => {
          walletPositions[wallet.id] = {
            x: levelX,
            y: 500 + (i + 1) * rowSpacing // Extreme vertical spacing
          };
        });
      });
      
      // Draw the links with VERY thin lines for less visual clutter
      g.selectAll('.link')
        .data(displayedLinks)
        .enter()
        .append('path')
        .attr('class', 'link')
        .attr('d', d => {
          // Get positions
          const sourcePos = walletPositions[d.source];
          const targetPos = walletPositions[d.target];
          
          if (!sourcePos || !targetPos) return '';
          
          // For curved paths:
          const midX = (sourcePos.x + targetPos.x) / 2;
          return `M${sourcePos.x},${sourcePos.y} 
                  C${midX},${sourcePos.y} 
                   ${midX},${targetPos.y} 
                   ${targetPos.x},${targetPos.y}`;
        })
        .attr('stroke', '#ffffff')
        .attr('stroke-width', d => Math.max(0.3, Math.sqrt(d.amount || 1) * 0.5)) // Very thin lines
        .attr('fill', 'none');
      
      // Only draw nodes if not showing all data (for performance)
      const shouldShowNodes = displayedLinks.length < 5000;
      
      if (shouldShowNodes) {
        // Draw the wallets as circles
        g.selectAll('.wallet-circle')
          .data(walletArray)
          .enter()
          .append('circle')
          .attr('cx', d => walletPositions[d.id]?.x || 0)
          .attr('cy', d => walletPositions[d.id]?.y || 0)
          .attr('r', 4) 
          .attr('fill', '#fff');
        
        // Draw wallet labels
        g.selectAll('.wallet-label')
          .data(walletArray)
          .enter()
          .append('text')
          .attr('class', 'node')
          .attr('x', d => walletPositions[d.id]?.x || 0)
          .attr('y', d => walletPositions[d.id]?.y - 10 || 0)
          .attr('text-anchor', 'middle')
          .text(d => d.id)
          .attr('font-size', '14px')
          .attr('font-weight', 'bold');
      }
      
      // Add level headers
      for (let i = 0; i <= maxLevel; i++) {
        g.append('text')
          .attr('x', 500 + i * columnWidth)
          .attr('y', 200) 
          .attr('text-anchor', 'middle')
          .attr('fill', 'rgba(255, 255, 255, 0.9)')
          .attr('font-size', '32px') // Very large font
          .attr('font-weight', 'bold')
          .text(i === 0 ? 'Original Wallets' : `Step ${i}`);
      }
      
      // Add stat text
      g.append('text')
        .attr('x', 100)
        .attr('y', 100)
        .attr('text-anchor', 'start')
        .attr('fill', 'rgba(255, 255, 255, 0.9)')
        .attr('font-size', '24px')
        .text(`Showing ${displayedLinks.length} of ${links.length} transactions (${uniqueWallets.size} wallets)`);
      
      // Initial view EXTREMELY zoomed out
      svg.call(
        zoom.transform,
        d3.zoomIdentity.scale(0.05) // Start extremely zoomed out
      );
      
      hideStatusMessage();
    }
    
    function centerView() {
      svg.transition()
        .duration(300)
        .call(
          zoom.transform,
          d3.zoomIdentity.scale(0.05) // Very zoomed out
        );
    }
    
    function updateStatus(message) {
      document.getElementById('status').textContent = message;
      console.log(message);
    }
    
    function updateProgress(percent) {
      document.getElementById('progress-bar').style.width = `${percent}%`;
    }
    
    function showStatusMessage(message) {
      const statusElement = document.getElementById('status-message');
      statusElement.textContent = message;
      statusElement.style.display = 'block';
    }
    
    function hideStatusMessage() {
      document.getElementById('status-message').style.display = 'none';
    }
    
    function showError(message) {
      const errorElement = document.getElementById('error');
      errorElement.textContent = message;
      errorElement.style.display = 'block';
      
      // Hide error after 10 seconds
      setTimeout(() => {
        errorElement.style.display = 'none';
      }, 10000);
      
      console.error(message);
    }
  </script>
</body>
</html>
