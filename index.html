<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Flow - Simple Tree</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #chart-container {
      width: 100%;
      height: 100%;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .link {
      stroke: #fff;
      stroke-opacity: 0.25;
    }
    
    .node {
      font-size: 14px;
      fill: #fff;
      text-anchor: middle;
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 24px;
      color: white;
    }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="chart-container"></div>

  <!-- Load D3.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      try {
        // Simple fixed data structure that matches your example
        const treeData = [
          {source: "A", target: "B"},
          {source: "B", target: "C"},
          {source: "B", target: "D"},
          {source: "B", target: "E"},
          {source: "F", target: "G"},
          {source: "H", target: "I"},
          {source: "J", target: "K"},
          {source: "K", target: "L"}
        ];
        
        // Draw the tree-like structure
        createSimpleTreeLayout(treeData);
        
        // Hide loading indicator
        document.getElementById('loading').style.display = 'none';
      } catch (error) {
        console.error("Error creating visualization:", error);
        document.getElementById('loading').innerHTML = "Error: " + error.message;
      }
    });
    
    function createSimpleTreeLayout(links) {
      const container = document.getElementById('chart-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      // Create SVG
      const svg = d3.select('#chart-container')
        .append('svg')
        .attr('width', width)
        .attr('height', height);
      
      // Create a group for the tree
      const g = svg.append('g')
        .attr('transform', `translate(50, 50)`);
      
      // Set up zoom behavior
      const zoom = d3.zoom()
        .scaleExtent([0.1, 10])
        .on('zoom', function(event) {
          g.attr('transform', event.transform);
        });
      
      svg.call(zoom);
      
      // Extract all unique nodes
      const nodesSet = new Set();
      links.forEach(link => {
        nodesSet.add(link.source);
        nodesSet.add(link.target);
      });
      
      // Create nodes array
      const nodes = Array.from(nodesSet).map(id => ({ id }));
      
      // Identify the levels of each node
      const nodeLevels = {};
      const sourcesOnly = new Set();  // Nodes that are only sources (initial nodes)
      const targetsOnly = new Set();  // Nodes that are only targets (end nodes)
      
      // Get all sources and targets
      links.forEach(link => {
        sourcesOnly.add(link.source);
        targetsOnly.add(link.target);
      });
      
      // Remove from sourcesOnly if also a target
      links.forEach(link => {
        if (targetsOnly.has(link.source)) {
          sourcesOnly.delete(link.source);
        }
      });
      
      // Remove from targetsOnly if also a source
      links.forEach(link => {
        if (sourcesOnly.has(link.target)) {
          targetsOnly.delete(link.target);
        }
      });
      
      // Assign levels starting from source-only nodes
      sourcesOnly.forEach(source => {
        nodeLevels[source] = 0;
        assignLevels(source, 0);
      });
      
      function assignLevels(nodeId, level) {
        const outgoingLinks = links.filter(link => link.source === nodeId);
        outgoingLinks.forEach(link => {
          // If target has no level yet, or current path gives a higher level
          if (nodeLevels[link.target] === undefined || nodeLevels[link.target] < level + 1) {
            nodeLevels[link.target] = level + 1;
            assignLevels(link.target, level + 1);
          }
        });
      }
      
      // Fallback for nodes not assigned a level
      nodes.forEach(node => {
        if (nodeLevels[node.id] === undefined) {
          nodeLevels[node.id] = 0; // Default to level 0
        }
      });
      
      // Get max level for column width calculation
      const maxLevel = Math.max(...Object.values(nodeLevels));
      
      // Group nodes by level
      const nodesByLevel = {};
      nodes.forEach(node => {
        const level = nodeLevels[node.id];
        if (!nodesByLevel[level]) {
          nodesByLevel[level] = [];
        }
        nodesByLevel[level].push(node);
      });
      
      // Assign positions to nodes
      const nodePositions = {};
      const columnWidth = width / (maxLevel + 2);
      
      Object.entries(nodesByLevel).forEach(([level, nodesInLevel]) => {
        const levelX = 100 + parseInt(level) * columnWidth;
        const rowHeight = height / (nodesInLevel.length + 1);
        
        nodesInLevel.forEach((node, i) => {
          nodePositions[node.id] = {
            x: levelX,
            y: (i + 1) * rowHeight
          };
        });
      });
      
      // Draw the links
      g.selectAll('.link')
        .data(links)
        .enter()
        .append('line')
        .attr('class', 'link')
        .attr('x1', d => nodePositions[d.source].x)
        .attr('y1', d => nodePositions[d.source].y)
        .attr('x2', d => nodePositions[d.target].x)
        .attr('y2', d => nodePositions[d.target].y)
        .attr('stroke', '#fff')
        .attr('stroke-width', 2);
      
      // Draw the nodes
      g.selectAll('.node')
        .data(nodes)
        .enter()
        .append('text')
        .attr('class', 'node')
        .attr('x', d => nodePositions[d.id].x)
        .attr('y', d => nodePositions[d.id].y)
        .attr('dy', '0.3em')
        .text(d => d.id)
        .attr('font-size', '20px')
        .attr('font-weight', 'bold');
      
      // Initial view
      svg.call(
        zoom.transform,
        d3.zoomIdentity.translate(width * 0.1, height * 0.1).scale(1)
      );
      
      // Add event to draw actual wallet data from CSV if available
      fetchRealDataIfAvailable();
    }
    
    function fetchRealDataIfAvailable() {
      // Try to fetch the combined.csv file
      fetch('combined.csv')
        .then(response => {
          if (!response.ok) {
            throw new Error(`CSV file not found or inaccessible.`);
          }
          return response.text();
        })
        .then(csvText => {
          console.log("CSV data available. Length:", csvText.length);
          // You could process real data here if needed
        })
        .catch(error => {
          console.log("Note: Using example data only.", error.message);
          // We're already showing example data, so no need to do anything
        });
    }
  </script>
</body>
</html>
