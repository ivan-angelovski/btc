<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Flow - Tree from CSV</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #chart-container {
      width: 100%;
      height: 100%;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .link {
      stroke: #fff;
      stroke-opacity: 0.2;
    }
    
    .node {
      font-size: 14px;
      fill: #fff;
      text-anchor: middle;
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 24px;
      color: white;
    }
    
    #error {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 15px;
      background-color: rgba(220, 53, 69, 0.9);
      color: white;
      border-radius: 4px;
      z-index: 1000;
      max-width: 80%;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Bitcoin Flow Data from CSV...</div>
  <div id="error" style="display: none;"></div>
  <div id="chart-container"></div>

  <!-- Load D3.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <!-- Load PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      loadCSVAndCreateTree();
    });
    
    async function loadCSVAndCreateTree() {
      const csvFile = 'combined.csv';
      
      try {
        console.log("Attempting to load CSV file:", csvFile);
        
        // Fetch CSV data
        const response = await fetch(csvFile);
        if (!response.ok) {
          throw new Error(`Failed to load CSV file: ${response.statusText}`);
        }
        
        const csvData = await response.text();
        console.log("CSV loaded successfully, length:", csvData.length);
        
        // Parse CSV
        Papa.parse(csvData, {
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true,
          complete: function(results) {
            if (results.errors.length > 0) {
              showError(`Error parsing CSV: ${results.errors[0].message}`);
              return;
            }
            
            try {
              const data = results.data;
              if (data.length === 0) {
                showError('No data found in the CSV file');
                return;
              }
              
              console.log("CSV parsed successfully, records:", data.length);
              
              // Process data and create tree
              const treeLinks = processCSVToTreeLinks(data);
              createTreeVisualization(treeLinks);
              
              // Hide loading indicator
              document.getElementById('loading').style.display = 'none';
            } catch (error) {
              showError(`Error processing data: ${error.message}`);
              console.error("Data processing error:", error);
            }
          },
          error: function(error) {
            showError(`Failed to parse CSV: ${error.message}`);
            console.error("CSV parsing error:", error);
          }
        });
      } catch (error) {
        showError(`Error: ${error.message}`);
        console.error("CSV loading error:", error);
      }
    }
    
    function processCSVToTreeLinks(csvData) {
      const firstRow = csvData[0];
      
      // Use the exact column names from your CSV
      let sourceColumn = "From (Full)";
      let targetColumn = "To (Full)";
      
      // Fallback column detection if needed
      if (!firstRow.hasOwnProperty(sourceColumn)) {
        const columns = Object.keys(firstRow);
        sourceColumn = columns.find(col => 
          col.toLowerCase().includes('from') || 
          col.toLowerCase().includes('source')
        ) || columns[0];
      }
      
      if (!firstRow.hasOwnProperty(targetColumn)) {
        const columns = Object.keys(firstRow);
        targetColumn = columns.find(col => 
          col.toLowerCase().includes('to') || 
          col.toLowerCase().includes('target')
        ) || columns[1];
      }
      
      console.log("Using columns:", sourceColumn, "->", targetColumn);
      
      // Extract links
      const links = [];
      csvData.forEach(row => {
        const source = row[sourceColumn];
        const target = row[targetColumn];
        
        // Use short versions if available
        const sourceShort = row["From (Short)"] || 
                           (typeof source === 'string' ? source.substring(0, 6) : source);
        const targetShort = row["To (Short)"] || 
                           (typeof target === 'string' ? target.substring(0, 6) : target);
        
        if (source && target && source !== target) {
          links.push({
            source: sourceShort,
            target: targetShort,
            originalSource: source,
            originalTarget: target,
            amount: row["Amount (BTC)"] || 1
          });
        }
      });
      
      console.log("Processed links:", links.length);
      return links;
    }
    
    function createTreeVisualization(links) {
      const container = document.getElementById('chart-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      // Create SVG
      const svg = d3.select('#chart-container')
        .append('svg')
        .attr('width', width)
        .attr('height', height);
      
      // Create a group for the tree
      const g = svg.append('g');
      
      // Set up zoom behavior
      const zoom = d3.zoom()
        .scaleExtent([0.1, 10])
        .on('zoom', function(event) {
          g.attr('transform', event.transform);
        });
      
      svg.call(zoom);
      
      // Extract all unique nodes
      const nodesSet = new Set();
      links.forEach(link => {
        nodesSet.add(link.source);
        nodesSet.add(link.target);
      });
      
      // Create nodes array
      const nodes = Array.from(nodesSet).map(id => ({ id }));
      
      // Identify the levels of each node
      const nodeLevels = {};
      const sourcesOnly = new Set();  // Nodes that are only sources (initial nodes)
      const targetsOnly = new Set();  // Nodes that are only targets (end nodes)
      
      // Get all sources and targets
      links.forEach(link => {
        sourcesOnly.add(link.source);
        targetsOnly.add(link.target);
      });
      
      // Remove from sourcesOnly if also a target
      links.forEach(link => {
        if (targetsOnly.has(link.source)) {
          sourcesOnly.delete(link.source);
        }
      });
      
      // Assign levels starting from source-only nodes
      sourcesOnly.forEach(source => {
        nodeLevels[source] = 0;
        assignLevels(source, 0);
      });
      
      function assignLevels(nodeId, level) {
        const outgoingLinks = links.filter(link => link.source === nodeId);
        outgoingLinks.forEach(link => {
          // If target has no level yet, or current path gives a higher level
          if (nodeLevels[link.target] === undefined || nodeLevels[link.target] < level + 1) {
            nodeLevels[link.target] = level + 1;
            assignLevels(link.target, level + 1);
          }
        });
      }
      
      // Fallback for nodes not assigned a level
      nodes.forEach(node => {
        if (nodeLevels[node.id] === undefined) {
          nodeLevels[node.id] = 0; // Default to level 0
        }
      });
      
      // Get max level for column width calculation
      const maxLevel = Math.max(...Object.values(nodeLevels));
      
      // Group nodes by level
      const nodesByLevel = {};
      nodes.forEach(node => {
        const level = nodeLevels[node.id];
        if (!nodesByLevel[level]) {
          nodesByLevel[level] = [];
        }
        nodesByLevel[level].push(node);
      });
      
      // Assign positions to nodes
      const nodePositions = {};
      const columnWidth = width / (maxLevel + 2);
      
      Object.entries(nodesByLevel).forEach(([level, nodesInLevel]) => {
        const levelX = 150 + parseInt(level) * columnWidth;
        const levelHeight = height - 200;
        const rowSpacing = levelHeight / (nodesInLevel.length + 1);
        
        nodesInLevel.forEach((node, i) => {
          nodePositions[node.id] = {
            x: levelX,
            y: 100 + (i + 1) * rowSpacing
          };
        });
      });
      
      // Draw the links
      g.selectAll('.link')
        .data(links)
        .enter()
        .append('path')
        .attr('class', 'link')
        .attr('d', d => {
          // Get positions
          const sourcePos = nodePositions[d.source];
          const targetPos = nodePositions[d.target];
          
          if (!sourcePos || !targetPos) return '';
          
          // For straight lines:
          // return `M${sourcePos.x},${sourcePos.y} L${targetPos.x},${targetPos.y}`;
          
          // For curved paths:
          const midX = (sourcePos.x + targetPos.x) / 2;
          return `M${sourcePos.x},${sourcePos.y} 
                  C${midX},${sourcePos.y} 
                   ${midX},${targetPos.y} 
                   ${targetPos.x},${targetPos.y}`;
        })
        .attr('stroke', '#ffffff')
        .attr('stroke-width', d => Math.sqrt(d.amount || 1) * 2)
        .attr('fill', 'none');
      
      // Draw the nodes
      g.selectAll('.node')
        .data(nodes)
        .enter()
        .append('text')
        .attr('class', 'node')
        .attr('x', d => nodePositions[d.id]?.x || 0)
        .attr('y', d => nodePositions[d.id]?.y || 0)
        .attr('dy', '0.3em')
        .text(d => d.id)
        .attr('font-size', '14px')
        .attr('font-weight', 'bold');
      
      // Add level headers
      for (let i = 0; i <= maxLevel; i++) {
        g.append('text')
          .attr('x', 150 + i * columnWidth)
          .attr('y', 50)
          .attr('text-anchor', 'middle')
          .attr('fill', 'rgba(255, 255, 255, 0.7)')
          .attr('font-size', '16px')
          .text(i === 0 ? 'Original Wallets' : `Step ${i}`);
      }
      
      // Initial zoom to fit
      const initialScale = 0.7;
      svg.call(
        zoom.transform,
        d3.zoomIdentity.translate(width * 0.1, height * 0.1).scale(initialScale)
      );
    }
    
    function showError(message) {
      const errorElement = document.getElementById('error');
      errorElement.textContent = message;
      errorElement.style.display = 'block';
      
      document.getElementById('loading').style.display = 'none';
      
      // Hide error after 10 seconds
      setTimeout(() => {
        errorElement.style.display = 'none';
      }, 10000);
      
      console.error(message);
    }
  </script>
</body>
</html>
