<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Wallet Flow</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #chart-container {
      width: 100%;
      height: 100%;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .link {
      fill: none;
      stroke: #fff;
    }
    
    .node rect {
      fill: #222;
      stroke: #fff;
      stroke-width: 3px;
    }
    
    .node text {
      fill: #fff;
      font-size: 14px;
      text-shadow: 0 0 5px #000, 0 0 5px #000, 0 0 5px #000;
    }
    
    .tooltip {
      position: absolute;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.9);
      color: white;
      border-radius: 4px;
      border: 2px solid rgba(255, 255, 255, 0.7);
      pointer-events: none;
      font-size: 14px;
      font-weight: bold;
      z-index: 10;
      max-width: 400px;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 24px;
      color: white;
    }
    
    #error {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 15px;
      background-color: rgba(220, 53, 69, 0.9);
      color: white;
      border-radius: 4px;
      z-index: 1000;
      max-width: 80%;
    }

    .node-label-bg {
      fill: rgba(0, 0, 0, 0.7);
      rx: 3;
      ry: 3;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Bitcoin Wallet Flow Data...</div>
  <div id="error" style="display: none;"></div>
  <div id="chart-container"></div>

  <!-- Load D3.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <!-- Load D3-Sankey -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-sankey/0.12.3/d3-sankey.min.js"></script>
  <!-- Load PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      createBitcoinFlowVisualization();
    });
    
    const initialScale = 0.8;
    
    // Create a simple sample data if file loading fails
    // This ensures something is always displayed
    const sampleData = {
      nodes: [
        {id: "wallet1", name: "16oQVSFH52hxhTYBxetzDPTdhN2M44pqR2", shortName: "16oQVS"},
        {id: "wallet2", name: "bc1qm34lsc65zpw79lxes69qmk6ee3ewf0j77s3h", shortName: "bc1qm3"},
        {id: "wallet3", name: "19xD3GmnBt38eVaJkTXgoLa4LPyQzce5VC", shortName: "19xD3G"},
        {id: "wallet4", name: "3QzYvaRFY5usMdAMMhTvEhZovLg3PCyWLs", shortName: "3QzYva"},
        {id: "wallet5", name: "1Ja52fHJrc1UPwRZ3JYFnipnhJm9Xtu1D2", shortName: "1Ja52f"},
        {id: "wallet6", name: "bc1q8c6fshw2dlwun7ekn9qwf37cu2rn755upcp7y4", shortName: "bc1q8c"}
      ],
      links: [
        {source: "wallet1", target: "wallet2", value: 2.5},
        {source: "wallet1", target: "wallet3", value: 1.2},
        {source: "wallet2", target: "wallet4", value: 1.7},
        {source: "wallet3", target: "wallet5", value: 0.8},
        {source: "wallet2", target: "wallet6", value: 0.5},
        {source: "wallet5", target: "wallet6", value: 0.3}
      ]
    };
    
    async function createBitcoinFlowVisualization() {
      const csvFile = 'combined.csv';
      
      // Create tooltip div
      const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);
      
      try {
        // Fetch CSV data
        const response = await fetch(csvFile);
        if (!response.ok) {
          throw new Error(`Failed to load CSV file: ${response.statusText}`);
        }
        
        const csvData = await response.text();
        processCSVData(csvData);
      } catch (error) {
        console.error(`Error loading CSV: ${error.message}`);
        // Use sample data if file loading fails
        createSankeyDiagram(sampleData, tooltip);
        hideLoading();
      }
      
      function processCSVData(csvText) {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true,
          complete: function(results) {
            if (results.errors.length > 0) {
              showError(`Error parsing CSV: ${results.errors[0].message}`);
              createSankeyDiagram(sampleData, tooltip);
              hideLoading();
              return;
            }
            
            try {
              const data = results.data;
              if (data.length === 0) {
                showError('No data found in the CSV file');
                createSankeyDiagram(sampleData, tooltip);
                hideLoading();
                return;
              }
              
              // Process data for Sankey diagram
              const sankeyData = processDataForSankey(data);
              
              // Create the diagram
              createSankeyDiagram(sankeyData, tooltip);
              
              // Hide loading indicator
              hideLoading();
            } catch (error) {
              showError(`Error processing data: ${error.message}`);
              createSankeyDiagram(sampleData, tooltip);
              hideLoading();
            }
          },
          error: function(error) {
            showError(`Failed to parse CSV: ${error.message}`);
            createSankeyDiagram(sampleData, tooltip);
            hideLoading();
          }
        });
      }
    }
    
    function processDataForSankey(rawData) {
      const firstRow = rawData[0];
      
      // Use the exact column names
      let sourceColumn = "From (Full)";
      let targetColumn = "To (Full)";
      let valueColumn = "Amount (BTC)";
      
      // Fallback column detection if needed
      if (!firstRow.hasOwnProperty(sourceColumn)) {
        const columns = Object.keys(firstRow);
        sourceColumn = columns.find(col => 
          col.toLowerCase().includes('from') || 
          col.toLowerCase().includes('source')
        ) || columns[0];
      }
      
      if (!firstRow.hasOwnProperty(targetColumn)) {
        const columns = Object.keys(firstRow);
        targetColumn = columns.find(col => 
          col.toLowerCase().includes('to') || 
          col.toLowerCase().includes('target')
        ) || columns[1];
      }
      
      if (!firstRow.hasOwnProperty(valueColumn)) {
        const columns = Object.keys(firstRow);
        valueColumn = columns.find(col => 
          col.toLowerCase().includes('amount') || 
          col.toLowerCase().includes('value') || 
          col.toLowerCase().includes('btc')
        );
      }
      
      // Create nodes and links
      const nodeMap = new Map();
      const links = [];
      
      // Process each row
      rawData.forEach(row => {
        const source = String(row[sourceColumn]);
        const target = String(row[targetColumn]);
        
        // Skip invalid rows
        if (!source || !target || source === target) return;
        
        // Get short names if available
        const sourceShort = row["From (Short)"] || source.substring(0, 6);
        const targetShort = row["To (Short)"] || target.substring(0, 6);
        
        // Add nodes if they don't exist
        if (!nodeMap.has(source)) {
          nodeMap.set(source, { 
            id: source, 
            name: source,
            shortName: sourceShort
          });
        }
        
        if (!nodeMap.has(target)) {
          nodeMap.set(target, { 
            id: target, 
            name: target,
            shortName: targetShort
          });
        }
        
        // Get value (default to 1 if not specified)
        const value = valueColumn && row[valueColumn] ? Number(row[valueColumn]) : 1;
        
        // Add link or update existing link
        const existingLink = links.find(link => 
          link.source === source && link.target === target);
        
        if (existingLink) {
          existingLink.value += value;
        } else {
          links.push({
            source: source,
            target: target,
            value: value
          });
        }
      });
      
      // Convert maps to arrays
      const nodes = Array.from(nodeMap.values());
      
      return { nodes, links };
    }
    
    function createSankeyDiagram(data, tooltip) {
      const container = document.getElementById('chart-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      // Remove any existing SVG
      d3.select('#chart-container').selectAll('*').remove();
      
      // Create new SVG
      const svg = d3.select('#chart-container')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height]);
      
      // Create a group for the Sankey diagram
      const g = svg.append('g');
      
      // Define zoom function
      function zoomed(event) {
        g.attr('transform', event.transform);
      }
      
      // Set up zoom behavior
      const zoom = d3.zoom()
        .scaleExtent([0.1, 10])
        .on('zoom', zoomed);
      
      // Apply zoom
      svg.call(zoom)
         .call(zoom.transform, d3.zoomIdentity.scale(initialScale).translate(width * 0.1, height * 0.1));
      
      // CRITICAL CHANGE: Use a very simple layout with just left and right sides
      // This dramatically spreads out nodes and makes everything more readable
      const sankey = d3.sankey()
        .nodeId(d => d.id)
        .nodeWidth(35)                     // Wider nodes
        .nodePadding(40)                   // More padding between nodes
        .nodeAlign(d3.sankeyJustify)       // Force nodes to left and right sides only
        .extent([[80, 20], [width - 150, height - 20]]);
      
      // Generate the Sankey layout
      const sankeyData = sankey(data);
      
      // Create background for link labels for better contrast
      const linkLabelBg = g.append("g")
        .attr("class", "link-label-backgrounds")
        .selectAll("rect")
        .data(sankeyData.links)
        .enter()
        .append("rect")
        .attr("class", "node-label-bg")
        .attr("rx", 3)
        .attr("ry", 3);
      
      // Draw the links
      const link = g.append('g')
        .attr('class', 'links')
        .attr('fill', 'none')
        .selectAll('path')
        .data(sankeyData.links)
        .enter().append('path')
        .attr('d', d3.sankeyLinkHorizontal())
        .attr('stroke', '#fff')
        .attr('stroke-width', d => Math.max(2, d.width)) // Minimum width of 2px for visibility
        .attr('stroke-opacity', 0.25)                   // Increased opacity
        .attr('class', 'link')
        .on('mouseover', function(event, d) {
          d3.select(this)
            .attr('stroke-opacity', 0.7)                // Higher contrast on hover
            .attr('stroke-width', d => Math.max(3, d.width + 3));
          
          // Show tooltip
          tooltip.transition()
            .duration(200)
            .style('opacity', 0.95);
          
          tooltip.html(`<strong>From:</strong> ${d.source.name}<br>` +
                      `<strong>To:</strong> ${d.target.name}<br>` +
                      `<strong>Amount:</strong> ${d.value.toFixed(8)} BTC`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
          d3.select(this)
            .attr('stroke-opacity', 0.25)
            .attr('stroke-width', d => Math.max(2, d.width));
          
          // Hide tooltip
          tooltip.transition()
            .duration(500)
            .style('opacity', 0);
        });
      
      // Draw the nodes
      const node = g.append('g')
        .attr('class', 'nodes')
        .selectAll('g')
        .data(sankeyData.nodes)
        .enter().append('g');
      
      // Add rectangles for the nodes
      node.append('rect')
        .attr('x', d => d.x0)
        .attr('y', d => d.y0)
        .attr('height', d => Math.max(30, d.y1 - d.y0))  // Ensure minimum height
        .attr('width', d => d.x1 - d.x0)
        .attr('fill', '#222')
        .attr('stroke', '#fff')
        .attr('stroke-width', 3)
        .attr('class', 'node')
        .on('mouseover', function(event, d) {
          d3.select(this)
            .attr('stroke-width', 4)
            .attr('stroke', '#fff');
          
          // Show tooltip
          tooltip.transition()
            .duration(200)
            .style('opacity', 0.95);
          
          tooltip.html(`<strong>Wallet:</strong> ${d.name}<br>` +
                      `<strong>Total Amount:</strong> ${d.value.toFixed(8)} BTC`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
          d3.select(this)
            .attr('stroke-width', 3);
          
          // Hide tooltip
          tooltip.transition()
            .duration(500)
            .style('opacity', 0);
        });
      
      // CRITICAL CHANGE: Add background rectangles for text labels
      const labelBg = node.append('rect')
        .attr('class', 'node-label-bg')
        .attr('x', d => d.x0 < width / 2 ? d.x0 - 120 : d.x1 + 10)
        .attr('y', d => (d.y1 + d.y0) / 2 - 10)
        .attr('width', 110)
        .attr('height', 20)
        .attr('fill', 'rgba(0, 0, 0, 0.7)')
        .attr('rx', 3)
        .attr('ry', 3);
      
      // Add labels for the nodes
      node.append('text')
        .attr('x', d => d.x0 < width / 2 ? d.x0 - 15 : d.x1 + 15)
        .attr('y', d => (d.y1 + d.y0) / 2)
        .attr('dy', '0.35em')
        .attr('text-anchor', d => d.x0 < width / 2 ? 'end' : 'start')
        .text(d => d.shortName || d.name.substring(0, 8))
        .attr('class', 'node-text')
        .style('pointer-events', 'none')
        .style('fill', '#fff')
        .style('font-size', '16px')
        .style('font-weight', 'bold');
      
      // Instructions on how to use
      svg.append('text')
        .attr('x', 10)
        .attr('y', height - 10)
        .attr('text-anchor', 'start')
        .attr('font-size', '12px')
        .attr('fill', 'rgba(255, 255, 255, 0.5)')
        .text('Scroll to zoom, drag to pan');
    }
    
    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }
    
    function showError(message) {
      const errorElement = document.getElementById('error');
      errorElement.textContent = message;
      errorElement.style.display = 'block';
      
      // Hide error after 10 seconds
      setTimeout(() => {
        errorElement.style.display = 'none';
      }, 10000);
    }
  </script>
</body>
</html>
