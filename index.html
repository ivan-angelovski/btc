<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Wallet Flow</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #chart-container {
      width: 100%;
      height: 100%;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .link {
      fill: none;
      stroke: #fff;
    }
    
    .node rect {
      fill: #222;
      stroke: #fff;
      stroke-width: 2px;
    }
    
    .node text {
      fill: #fff;
      font-size: 14px;
    }
    
    .tooltip {
      position: absolute;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.9);
      color: white;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      pointer-events: none;
      font-size: 14px;
      z-index: 10;
      max-width: 400px;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 24px;
      color: white;
    }
    
    #error {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 15px;
      background-color: rgba(220, 53, 69, 0.9);
      color: white;
      border-radius: 4px;
      z-index: 1000;
      max-width: 80%;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Bitcoin Wallet Flow Data...</div>
  <div id="error" style="display: none;"></div>
  <div id="chart-container"></div>

  <!-- Load D3.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <!-- Load D3-Sankey -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-sankey/0.12.3/d3-sankey.min.js"></script>
  <!-- Load PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      createBitcoinFlowVisualization();
    });
    
    // Initial scale is very zoomed out to show the full network
    const initialScale = 0.5;
    
    async function createBitcoinFlowVisualization() {
      const csvFile = 'combined.csv';
      
      // Create tooltip div
      const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);
      
      try {
        // Fetch CSV data
        const response = await fetch(csvFile);
        if (!response.ok) {
          throw new Error(`Failed to load CSV file: ${response.statusText}`);
        }
        
        const csvData = await response.text();
        processCSVData(csvData);
      } catch (error) {
        showError(`Error: ${error.message}`);
        hideLoading();
      }
      
      function processCSVData(csvText) {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true,
          complete: function(results) {
            if (results.errors.length > 0) {
              showError(`Error parsing CSV: ${results.errors[0].message}`);
              hideLoading();
              return;
            }
            
            try {
              const data = results.data;
              if (data.length === 0) {
                showError('No data found in the CSV file');
                hideLoading();
                return;
              }
              
              // Process data for Sankey diagram
              const sankeyData = processDataForSankey(data);
              
              // Create the diagram
              createSankeyDiagram(sankeyData, tooltip);
              
              // Hide loading indicator
              hideLoading();
            } catch (error) {
              showError(`Error processing data: ${error.message}`);
              hideLoading();
            }
          },
          error: function(error) {
            showError(`Failed to parse CSV: ${error.message}`);
            hideLoading();
          }
        });
      }
    }
    
    function processDataForSankey(rawData) {
      const firstRow = rawData[0];
      
      // Use the exact column names
      let sourceColumn = "From (Full)";
      let targetColumn = "To (Full)";
      let valueColumn = "Amount (BTC)";
      
      // Fallback column detection if needed
      if (!firstRow.hasOwnProperty(sourceColumn)) {
        const columns = Object.keys(firstRow);
        sourceColumn = columns.find(col => 
          col.toLowerCase().includes('from') || 
          col.toLowerCase().includes('source')
        ) || columns[0];
      }
      
      if (!firstRow.hasOwnProperty(targetColumn)) {
        const columns = Object.keys(firstRow);
        targetColumn = columns.find(col => 
          col.toLowerCase().includes('to') || 
          col.toLowerCase().includes('target')
        ) || columns[1];
      }
      
      if (!firstRow.hasOwnProperty(valueColumn)) {
        const columns = Object.keys(firstRow);
        valueColumn = columns.find(col => 
          col.toLowerCase().includes('amount') || 
          col.toLowerCase().includes('value') || 
          col.toLowerCase().includes('btc')
        );
      }
      
      // Create nodes and links
      const nodeMap = new Map();
      const links = [];
      
      // Process each row
      rawData.forEach(row => {
        const source = String(row[sourceColumn]);
        const target = String(row[targetColumn]);
        
        // Skip invalid rows
        if (!source || !target || source === target) return;
        
        // Get short names if available
        const sourceShort = row["From (Short)"] || source.substring(0, 6);
        const targetShort = row["To (Short)"] || target.substring(0, 6);
        
        // Add nodes if they don't exist
        if (!nodeMap.has(source)) {
          nodeMap.set(source, { 
            id: source, 
            name: source,
            shortName: sourceShort
          });
        }
        
        if (!nodeMap.has(target)) {
          nodeMap.set(target, { 
            id: target, 
            name: target,
            shortName: targetShort
          });
        }
        
        // Get value (default to 1 if not specified)
        const value = valueColumn && row[valueColumn] ? Number(row[valueColumn]) : 1;
        
        // Add link or update existing link
        const existingLink = links.find(link => 
          link.source === source && link.target === target);
        
        if (existingLink) {
          existingLink.value += value;
        } else {
          links.push({
            source: source,
            target: target,
            value: value
          });
        }
      });
      
      // Convert maps to arrays
      const nodes = Array.from(nodeMap.values());
      
      return { nodes, links };
    }
    
    function createSankeyDiagram(data, tooltip) {
      const container = document.getElementById('chart-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      // For 4K support, we'll create a very large virtual canvas
      // This allows full spreading of the diagram
      const virtualWidth = Math.max(width * 3, 5000);
      const virtualHeight = Math.max(height * 3, 3000);
      
      // Remove any existing SVG
      d3.select('#chart-container').selectAll('*').remove();
      
      // Create new SVG with the virtual size as viewBox
      const svg = d3.select('#chart-container')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, virtualWidth, virtualHeight]);
      
      // Create a group for the Sankey diagram
      const g = svg.append('g');
      
      // Define zoom function
      function zoomed(event) {
        g.attr('transform', event.transform);
      }
      
      // Set up zoom behavior
      const zoom = d3.zoom()
        .scaleExtent([0.05, 10])  // Allow much more zooming out
        .on('zoom', zoomed);
      
      // Apply zoom, initially centered and zoomed out
      svg.call(zoom)
         .call(zoom.transform, d3.zoomIdentity
           .scale(initialScale)
           .translate(virtualWidth/4, virtualHeight/4));
      
      // Initialize the Sankey generator with extreme spacing
      // This spreads nodes across the entire virtual canvas
      const sankey = d3.sankey()
        .nodeId(d => d.id)
        .nodeWidth(20)
        .nodePadding(100)  // Very large padding between nodes
        .extent([[50, 50], [virtualWidth - 50, virtualHeight - 50]]);
      
      // Generate the Sankey layout
      const sankeyData = sankey(data);
      
      // Draw the links - very transparent by default
      const link = g.append('g')
        .attr('class', 'links')
        .attr('fill', 'none')
        .selectAll('path')
        .data(sankeyData.links)
        .enter().append('path')
        .attr('d', d3.sankeyLinkHorizontal())
        .attr('stroke', '#ffffff')
        .attr('stroke-width', d => Math.max(1, d.width))
        .attr('stroke-opacity', 0.1)  // Very transparent by default
        .attr('class', 'link')
        .on('mouseover', function(event, d) {
          d3.select(this)
            .attr('stroke-opacity', 0.5)  // More visible on hover
            .attr('stroke-width', d => Math.max(2, d.width + 2));
          
          // Show tooltip
          tooltip.transition()
            .duration(200)
            .style('opacity', 0.9);
          
          tooltip.html(`<strong>From:</strong> ${d.source.name}<br>` +
                      `<strong>To:</strong> ${d.target.name}<br>` +
                      `<strong>Amount:</strong> ${d.value.toFixed(8)} BTC`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
          d3.select(this)
            .attr('stroke-opacity', 0.1)
            .attr('stroke-width', d => Math.max(1, d.width));
          
          // Hide tooltip
          tooltip.transition()
            .duration(500)
            .style('opacity', 0);
        });
      
      // Draw the nodes
      const node = g.append('g')
        .attr('class', 'nodes')
        .selectAll('g')
        .data(sankeyData.nodes)
        .enter().append('g');
      
      // Add rectangles for the nodes
      node.append('rect')
        .attr('x', d => d.x0)
        .attr('y', d => d.y0)
        .attr('height', d => Math.max(15, d.y1 - d.y0))
        .attr('width', d => d.x1 - d.x0)
        .attr('fill', '#222')
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .attr('class', 'node')
        .on('mouseover', function(event, d) {
          d3.select(this)
            .attr('stroke-width', 3)
            .attr('stroke', '#fff');
          
          // Show tooltip
          tooltip.transition()
            .duration(200)
            .style('opacity', 0.9);
          
          tooltip.html(`<strong>Wallet:</strong> ${d.name}<br>` +
                      `<strong>Total Amount:</strong> ${d.value.toFixed(8)} BTC`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
          d3.select(this)
            .attr('stroke-width', 2);
          
          // Hide tooltip
          tooltip.transition()
            .duration(500)
            .style('opacity', 0);
        });
      
      // Add labels for the nodes on opposite sides
      node.append('text')
        .attr('x', d => d.x0 < virtualWidth / 2 ? d.x0 - 8 : d.x1 + 8)
        .attr('y', d => (d.y1 + d.y0) / 2)
        .attr('dy', '0.35em')
        .attr('text-anchor', d => d.x0 < virtualWidth / 2 ? 'end' : 'start')
        .text(d => d.shortName || d.name.substring(0, 6))
        .attr('class', 'node-text')
        .style('pointer-events', 'none')
        .style('fill', '#ffffff')
        .style('font-size', '14px');
      
      // Add subtle hint text
      svg.append('text')
        .attr('x', 20)
        .attr('y', virtualHeight - 20)
        .attr('text-anchor', 'start')
        .attr('font-size', '14px')
        .attr('fill', 'rgba(255, 255, 255, 0.3)')
        .text('Scroll to zoom, drag to pan');
    }
    
    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }
    
    function showError(message) {
      const errorElement = document.getElementById('error');
      errorElement.textContent = message;
      errorElement.style.display = 'block';
      
      // Hide error after 10 seconds
      setTimeout(() => {
        errorElement.style.display = 'none';
      }, 10000);
    }
  </script>
</body>
</html>
