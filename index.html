<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Flow - No Overlap</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #chart-container {
      width: 100%;
      height: 100%;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .tooltip {
      position: absolute;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.9);
      color: white;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      pointer-events: none;
      font-size: 14px;
      z-index: 10;
      max-width: 400px;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 24px;
      color: white;
    }
    
    #error {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 15px;
      background-color: rgba(220, 53, 69, 0.9);
      color: white;
      border-radius: 4px;
      z-index: 1000;
      max-width: 80%;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Bitcoin Flow Data...</div>
  <div id="error" style="display: none;"></div>
  <div id="chart-container"></div>

  <!-- Load D3.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <!-- Load PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      createBitcoinFlowVisualization();
    });
    
    // Fixed data for testing - uncomment to use sample data
    // const SAMPLE_DATA = [
    //   {source: "Wallet1", target: "Wallet2", value: 2.5},
    //   {source: "Wallet1", target: "Wallet3", value: 1.2},
    //   {source: "Wallet2", target: "Wallet4", value: 1.7},
    //   {source: "Wallet3", target: "Wallet5", value: 0.8}
    // ];
    
    async function createBitcoinFlowVisualization() {
      const csvFile = 'combined.csv';
      
      // Create tooltip div
      const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);
      
      try {
        // Fetch CSV data
        const response = await fetch(csvFile);
        if (!response.ok) {
          throw new Error(`Failed to load CSV file: ${response.statusText}`);
        }
        
        const csvData = await response.text();
        processCSVData(csvData);
      } catch (error) {
        showError(`Error: ${error.message}`);
        hideLoading();
        
        // If you want to show sample data instead when file loading fails, uncomment:
        // createForcedRadialLayout(SAMPLE_DATA, tooltip);
      }
      
      function processCSVData(csvText) {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true,
          complete: function(results) {
            if (results.errors.length > 0) {
              showError(`Error parsing CSV: ${results.errors[0].message}`);
              hideLoading();
              return;
            }
            
            try {
              const data = results.data;
              if (data.length === 0) {
                showError('No data found in the CSV file');
                hideLoading();
                return;
              }
              
              // Process data for visualization
              const flowLinks = processDataForFlowLinks(data);
              
              // Create the visualization with absolutely no overlap
              createForcedRadialLayout(flowLinks, tooltip);
              
              // Hide loading indicator
              hideLoading();
            } catch (error) {
              showError(`Error processing data: ${error.message}`);
              hideLoading();
            }
          },
          error: function(error) {
            showError(`Failed to parse CSV: ${error.message}`);
            hideLoading();
          }
        });
      }
    }
    
    function processDataForFlowLinks(rawData) {
      const firstRow = rawData[0];
      
      // Use the exact column names
      let sourceColumn = "From (Full)";
      let targetColumn = "To (Full)";
      let valueColumn = "Amount (BTC)";
      
      // Fallback column detection if needed
      if (!firstRow.hasOwnProperty(sourceColumn)) {
        const columns = Object.keys(firstRow);
        sourceColumn = columns.find(col => 
          col.toLowerCase().includes('from') || 
          col.toLowerCase().includes('source')
        ) || columns[0];
      }
      
      if (!firstRow.hasOwnProperty(targetColumn)) {
        const columns = Object.keys(firstRow);
        targetColumn = columns.find(col => 
          col.toLowerCase().includes('to') || 
          col.toLowerCase().includes('target')
        ) || columns[1];
      }
      
      if (!firstRow.hasOwnProperty(valueColumn)) {
        const columns = Object.keys(firstRow);
        valueColumn = columns.find(col => 
          col.toLowerCase().includes('amount') || 
          col.toLowerCase().includes('value') || 
          col.toLowerCase().includes('btc')
        );
      }
      
      // Create links array
      const links = [];
      
      // Process each row
      rawData.forEach(row => {
        const source = String(row[sourceColumn]);
        const target = String(row[targetColumn]);
        
        // Skip invalid rows
        if (!source || !target || source === target) return;
        
        // Get short names if available
        const sourceShort = row["From (Short)"] || source.substring(0, 6);
        const targetShort = row["To (Short)"] || target.substring(0, 6);
        
        // Get value (default to 1 if not specified)
        const value = valueColumn && row[valueColumn] ? Number(row[valueColumn]) : 1;
        
        // Add to links
        links.push({
          source,
          target,
          sourceShort,
          targetShort,
          value
        });
      });
      
      return links;
    }
    
    function createForcedRadialLayout(links, tooltip) {
      const container = document.getElementById('chart-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      // Create a slightly larger virtual canvas
      const virtualWidth = Math.max(width, 1920);
      const virtualHeight = Math.max(height, 1080);
      
      // Remove any existing SVG
      d3.select('#chart-container').selectAll('*').remove();
      
      // Create new SVG with the virtual size as viewBox
      const svg = d3.select('#chart-container')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, virtualWidth, virtualHeight]);
      
      // Create a group for the flow diagram
      const g = svg.append('g')
        .attr('transform', `translate(${virtualWidth/2},${virtualHeight/2})`);
      
      // Define zoom function
      function zoomed(event) {
        g.attr('transform', `translate(${event.transform.x + virtualWidth/2},${event.transform.y + virtualHeight/2}) scale(${event.transform.k})`);
      }
      
      // Set up zoom behavior
      const zoom = d3.zoom()
        .scaleExtent([0.1, 10])
        .on('zoom', zoomed);
      
      // Apply zoom
      svg.call(zoom);
      
      // Extract all unique wallets (nodes)
      const nodes = new Map();
      
      links.forEach(link => {
        if (!nodes.has(link.source)) {
          nodes.set(link.source, { 
            id: link.source, 
            name: link.source,
            shortName: link.sourceShort,
            isSource: true,
            isTarget: false
          });
        } else {
          // Update existing node
          const node = nodes.get(link.source);
          node.isSource = true;
        }
        
        if (!nodes.has(link.target)) {
          nodes.set(link.target, { 
            id: link.target, 
            name: link.target,
            shortName: link.targetShort,
            isSource: false,
            isTarget: true
          });
        } else {
          // Update existing node
          const node = nodes.get(link.target);
          node.isTarget = true;
        }
      });
      
      const nodeArray = Array.from(nodes.values());
      
      // Setup positions for nodes in a circular layout
      // We'll put source-only nodes on the left side
      // target-only nodes on the right side
      // and nodes that are both source and target in the middle
      
      // Sort nodes by type
      const sourceOnlyNodes = nodeArray.filter(node => node.isSource && !node.isTarget);
      const targetOnlyNodes = nodeArray.filter(node => !node.isSource && node.isTarget);
      const mixedNodes = nodeArray.filter(node => node.isSource && node.isTarget);
      
      // Calculate angles for even distribution
      function assignPositions(nodeList, startAngle, endAngle, radius) {
        const angleStep = (endAngle - startAngle) / Math.max(nodeList.length, 1);
        
        nodeList.forEach((node, i) => {
          const angle = startAngle + i * angleStep;
          node.x = radius * Math.cos(angle);
          node.y = radius * Math.sin(angle);
          node.angle = angle;
        });
      }
      
      // Assign positions for different node types
      // Source nodes on left (180-360 degrees)
      assignPositions(sourceOnlyNodes, Math.PI, Math.PI * 2, virtualHeight * 0.4);
      
      // Target nodes on right (0-180 degrees)
      assignPositions(targetOnlyNodes, 0, Math.PI, virtualHeight * 0.4);
      
      // Mixed nodes in middle circle
      assignPositions(mixedNodes, 0, Math.PI * 2, virtualHeight * 0.2);
      
      // Draw the flow lines - each gets its own path
      const flowPaths = g.selectAll('.link')
        .data(links)
        .enter()
        .append('path')
        .attr('class', 'link')
        .attr('d', d => {
          const sourceNode = nodes.get(d.source);
          const targetNode = nodes.get(d.target);
          
          // Calculate control points for the curve
          // We'll make a curved path that doesn't cross the center
          const sourceRadius = Math.sqrt(sourceNode.x * sourceNode.x + sourceNode.y * sourceNode.y);
          const targetRadius = Math.sqrt(targetNode.x * targetNode.x + targetNode.y * targetNode.y);
          
          const sourceAngle = Math.atan2(sourceNode.y, sourceNode.x);
          const targetAngle = Math.atan2(targetNode.y, targetNode.x);
          
          // Control points: we'll curve the path outward
          const midAngle = (sourceAngle + targetAngle) / 2;
          const controlDistance = Math.max(sourceRadius, targetRadius) * 1.2;
          
          const controlX = controlDistance * Math.cos(midAngle);
          const controlY = controlDistance * Math.sin(midAngle);
          
          // Create a quadratic curve path
          return `M${sourceNode.x},${sourceNode.y} Q${controlX},${controlY} ${targetNode.x},${targetNode.y}`;
        })
        .attr('stroke', '#ffffff')
        .attr('stroke-width', d => Math.sqrt(d.value) * 1.5) // Scale width by square root of value
        .attr('stroke-opacity', 0.15)
        .attr('fill', 'none')
        .on('mouseover', function(event, d) {
          d3.select(this)
            .attr('stroke-opacity', 0.6)
            .attr('stroke-width', d => Math.sqrt(d.value) * 2);
          
          // Show tooltip
          tooltip.transition()
            .duration(200)
            .style('opacity', 0.9);
          
          tooltip.html(`<strong>From:</strong> ${d.sourceShort}<br>` +
                      `<strong>To:</strong> ${d.targetShort}<br>` +
                      `<strong>Amount:</strong> ${d.value.toFixed(8)} BTC`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
          d3.select(this)
            .attr('stroke-opacity', 0.15)
            .attr('stroke-width', d => Math.sqrt(d.value) * 1.5);
          
          // Hide tooltip
          tooltip.transition()
            .duration(500)
            .style('opacity', 0);
        });
      
      // Add small wallet labels
      g.selectAll('.node-label')
        .data(nodeArray)
        .enter()
        .append('text')
        .attr('x', d => d.x * 1.05) // Slightly offset from the node position
        .attr('y', d => d.y * 1.05)
        .attr('text-anchor', 'middle')
        .attr('font-size', '10px')
        .attr('fill', 'rgba(255, 255, 255, 0.7)')
        .text(d => d.shortName);
      
      // Add subtle hint text
      svg.append('text')
        .attr('x', 20)
        .attr('y', virtualHeight - 20)
        .attr('text-anchor', 'start')
        .attr('font-size', '14px')
        .attr('fill', 'rgba(255, 255, 255, 0.3)')
        .text('Scroll to zoom, drag to pan');
    }
    
    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }
    
    function showError(message) {
      const errorElement = document.getElementById('error');
      errorElement.textContent = message;
      errorElement.style.display = 'block';
      
      // Hide error after 10 seconds
      setTimeout(() => {
        errorElement.style.display = 'none';
      }, 10000);
    }
  </script>
</body>
</html>
